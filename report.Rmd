---
title: "Cross-selling in Banking"
author: Adrian Meier, Benjamin Wuermli
output:
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
    toc_float: true
  html_notebook:
    toc: yes
    toc_depth: 4
    df_print: paged
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    theme: united
    highlight: tango
    code_folding: show
---

### Imports
```{r}
# install.packages("tidyverse")
# install.packages("ggmosaic")
# install.packages("GGally")
# install.packages("randomForest")
# install.packages("caret")

required_packages <- c("tidyverse", "ggmosaic", "GGally", "randomForest", "caret") # add more as needed

for (pkg in required_packages) {
    if (!require(pkg, character.only = TRUE)) {
        install.packages(pkg)
        library(pkg, character.only = TRUE)
    }
}

# library(tidyverse)
# library(ggmosaic)
# library(GGally)
# library(lubridate)
# library(randomForest)
# library(caret)
```
# Verfügbare Tabellen untersuchen

## account Datensatz
```{r}
accounts <- read.csv("data/account.csv", sep=";")
glimpse(accounts)
summary(accounts)
sum(is.na(accounts))
length(unique(accounts$account_id)) == nrow(accounts)
```

Im ersten schritt wollen wir die Daten der Tabelle accounts verständlicher machen. Dabei wollen wir die tschechischen Namen in der Kategorie "frequency" auf Deutsch übersetzen und con einem <chr> in einen <fct> umwandeln  und das Datum in das richtige Format bringen.
```{r}
#Ändern der tschechischen Namen in der Spalte frequency
accounts <- accounts %>%
  mutate(frequency = case_when(frequency == "POPLATEK MESICNE" ~ "Monatliche Ausgabe",
                               frequency == "POPLATEK TYDNE" ~ "Wöchentliche Ausgabe",
                               frequency == "POPLATEK PO OBRATU" ~ "Ausgabe nach Transaktion"))
```

```{r}
#Frequency in Faktor umwandeln
accounts <- accounts %>% 
  mutate(frequency = as.factor(frequency))
```

```{r}
# Datum umwandeln
accounts$date <- ymd(accounts$date)

# spalten umbenennen
accounts <- accounts %>%
  rename(opening_date = date,
         frequency_of_statements = frequency,
         district_id_account = district_id)
```

Die Werte sind nun bereinigt und man sieht bei frequency die drei Ausgabedaten, zudem ist das Datum nun auch als Datum erfasst.
```{r}
glimpse(accounts)
summary(accounts)
```
```{r}
barplot(table(accounts$district_id), main = "Distribution of Accounts by District", xlab = "District ID", ylab = "Number of Accounts")
```

```{r}
ggplot(accounts, aes(x = frequency_of_statements, fill = frequency_of_statements)) +
  geom_bar() +
  geom_text(stat = 'count',
            aes(label = ..count..), 
            position = position_stack(vjust = 0.5)
            ) +
  labs(title = "Frequenz der Kontoauszüge",
       x = "Frequenz",
       y = "Anzahl Konten",
       fill = "Ausgabe"
       ) +
  coord_flip()
```
```{r}
ggplot(accounts, aes(x = opening_date)) +
  geom_histogram(binwidth = 7) +
  ggtitle("Accounteröffnungen pro Woche")
```

## card Datensatz
```{r}
card <- read.csv("data/card.csv", sep=";")
glimpse(card)
summary(card)
sum(is.na(card))
length(unique(card$card_id)) == nrow(card)
```

Bei diesem Datensatz änern wir zuerst die "type" Spalte wie oben in einen Faktor.
```{r}
#Type in Faktor umwandeln
card <- card %>%
  rename(card_type = type)

card <- card %>% 
  mutate(card_type = as.factor(card_type))
```

Anschliessend wird die spalte "issued" bearbeitet. Bei dieser sollen die ersten sechs Zeichen als Datum gewertet werden. Die 00:00:00 benötigen wir dabei nicht mehr, da diese bei allen Daten hintendran stehen.
```{r}
# Datum umwandeln
card$issued <- ymd(substr(card$issued, 1, 6))
```

Der Card Datensatz sollte nun korrekt sein.
```{r}
glimpse(card)
summary(card)
```
```{r}
card %>%
  group_by(card_type) %>%
  summarise(count = n())
```

## client Datensatz
```{r}
client <- read.csv("data/client.csv", sep=";")
glimpse(client)
summary(client)
sum(is.na(client))
length(unique(client$client_id)) == nrow(client)
```

Bei diesem Datensatz ist wichtig zu wissen, dass in der birth_number zudem das Geschlecht gespeichert ist. Bei Frauen wurde die angabe des Monats um 50 erhöht. D.h YYMMDD für Männer und YYMM+50DD für Frauen. Deshalb wollen wir eine zusätzliche Spalte für das Geschlecht erzeugen und die Geburtsdaten dann bereinigt in der birth number wiedergeben.
```{r}
#Unterscheidung von Mann und Frau anhand vom Geburtsdatum
client <- client %>%
  mutate(
    sex = ifelse((birth_number %% 10000) > 2000, "female", "male")
  )

#Ändern des Datentyps der Reihe
client <- client %>% 
  mutate(sex = as.factor(sex))
```

Da wir nun die Kategorie des Geschlechts haben wollen wir noch das Geburtsdatum anpassen und im richtigen Format ausgeben.
```{r}
#Geburtsdatum bei den Frauen um 5000 subtrahieren. Damit wieder der normale Monat angezeigt wird.
client$birth_number[client$sex == "female"] <- client$birth_number[client$sex == "female"]-5000


#Der <int> wird in ein Datum umgewandelt.
client <- client %>%
  mutate(birth_number = birth_number + 19000000)
client$birth_number <- ymd(client$birth_number)

client <- client %>%
  rename(birthday = birth_number,
         district_id_client = district_id)

client$year <- year(client$birthday)
```

Der Client Datensatz sollte nun korrekt sein und die Spalte sex enthalten.
```{r}
glimpse(client)
summary(client)
```
```{r}
 install.packages("ggridges")
 library(ggridges)

ggplot(client, aes(x = year, y = sex, fill = sex)) +
  geom_density_ridges() +
  theme_ridges() +  # This is a theme provided by ggridges
  labs(title = "Ridge Line Plot of Year by Sex",
       x = "Year",
       y = "Sex")

ggplot(client, aes(x = year, y = district_id_client)) +
  geom_point() +  # Adds the data points
  geom_smooth(method = "lm",   # lm for linear model
              se = TRUE,       # se = TRUE to show confidence interval
              color = "blue", 
              fill = "lightblue") +
  theme_minimal() +
  labs(title = "Regression of District ID on Year with Confidence Interval",
       x = "Year",
       y = "District ID")

ggplot(client, aes(x = year, y = district_id_client, color = sex)) + 
  geom_point() +
  theme_minimal() +
  labs(title = "Scatter Plot by Year and District ID",
       x = "Year",
       y = "District ID",
       color = "Sex") +
  theme(legend.position = "bottom")

ggplot(client, aes(x = district_id_client, y = year, color = sex, size = year)) + 
  geom_point(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Bubble Chart by Year and District ID",
       x = "Year",
       y = "District ID",
       color = "Sex",
       size = "Year") +
  theme(legend.position = "bottom")

ggplot(client, aes(x = sex, y = year, color = sex)) + 
  geom_violin(trim = FALSE) + 
  geom_jitter(width = 0.2, alpha = 0.5) +
  theme_minimal() +
  labs(title = "Violin and Scatter Plot by Year and Sex",
       x = "Sex",
       y = "Year")

ggplot(client, aes(x = sex, y = year, color = sex)) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.5) +
  theme_minimal() +
  labs(title = "Categorical Strip Plot with Jitter",
       x = "Sex",
       y = "Year")

ggplot(client, aes(x = year, fill = sex)) +
  geom_density(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Conditional Density Plot of Year by Sex",
       x = "Year",
       y = "Density")
```

## disp Datensatz
```{r}
disp <- read.csv("data/disp.csv", sep=";")
glimpse(disp)
summary(disp)
sum(is.na(disp))
length(unique(disp$disp_id)) == nrow(disp)
```

Hier wollen wir nur den type von <chr> in <fct> ändern und anschliessend kontrollieren.
```{r}
#Type in Faktor umwandeln
disp <- disp %>% 
  mutate(type = as.factor(type))

#Ausgabe von disp zur Kontrolle
glimpse(disp)
summary(disp)
```

## district Datensatz
```{r}
district <- read.csv("data/district.csv", sep=";")
glimpse(district)
summary(district)
sum(is.na(district))
length(unique(district$A1)) == nrow(district)
```

Hier werden alle Spalten mit A angegeben, dies sollen aussagekräftigere Namen werden.
```{r}
#Spaltennamen ändern
colnames(district) <- c("district_id", "district_name", "region", "inhabitants", "municipalities<499", "municipalities500-1999", "municipalities2000-9999", "municipalities>10000", "cities", "urban_inhabitants", "average_salary", "unemploymant_rate_95", "unemploymant_rate_96", "enterpreneurs_per_1000", "commited_crimes_95", "commited_crimes_96")
```

Nun sollen noch alle <chr> in andere Formate geändert werden. Die Warnung nach ausführung des Codes ist auf den District Jesenik bezogen. Dort ist in der Spalte unemploymant_rate_95 und commited_crimes_95 ein "?" eigetragen, dieser Wert wird mit NA ersetzt.
```{r}
district <- district %>% 
  mutate(district_name = as.factor(district_name),
        region = as.factor(region),
        unemploymant_rate_95 = as.double(unemploymant_rate_95),
        commited_crimes_95 = as.integer(commited_crimes_95))

```

Kontrolle der geänderten Tabelle.
```{r}
glimpse(district)
summary(district)
```
```{r}
district <- district %>%
  mutate(crimes_per_1000_1995 = commited_crimes_95/inhabitants*1000)

ggplot(district, aes(x = unemploymant_rate_96, y = crimes_per_1000_1995)) +
  geom_point(alpha = 0.5) +
  labs(title = "Scatter Plot of Unemployment Rate and Committed Crimes in 1995",
       x = "Unemployment Rate in 1995",
       y = "Committed Crimes per 1000 in 1995")
```
```{r}
district <- district %>%
  mutate(crimes_per_1000_1996 = (commited_crimes_96/inhabitants)*1000)

ggplot(district, aes(x = unemploymant_rate_96, y = crimes_per_1000_1996)) +
  geom_point(alpha = 0.5) +
  labs(title = "Scatter Plot of Unemployment Rate and Committed Crimes in 1996",
       x = "Unemployment Rate in 1996",
       y = "Committed Crimes per 1000 in 1996")
```
```{r}
district %>%
  filter(commited_crimes_95 == 85677)

district %>%
  filter(commited_crimes_96 == 99107)
```
```{r}
ggplot(district, aes(x = inhabitants, y = commited_crimes_95)) +
  geom_point(alpha = 0.5) +
  labs(title = "Scatter Plot of Inhabitants vs Crimes in 95",
       x = "Number of Inhabitants",
       y = "Number of Crimes")

ggplot(district, aes(x = inhabitants, y = commited_crimes_96)) +
  geom_point(alpha = 0.5) +
  labs(title = "Scatter Plot of Inhabitants vs Crimes in 96",
       x = "Number of Inhabitants",
       y = "Number of Crimes")
```

## loan Datensatz
```{r}
loan <- read.csv("data/loan.csv", sep=";")
glimpse(loan)
summary(loan)
sum(is.na(loan))
length(unique(loan$loan_id)) == nrow(loan)
length(unique(loan$account_id)) == nrow(loan)
```

Ändern der Spalte status, A, B, C,D soll mit aussagekräftigeren Namen ersetzt werden, anschiessend soll sie noch zu <fct> geändert werden.
```{r}
#Ändern der Namen in Status
loan <- loan %>%
  mutate(status = case_when(status == "A" ~ "finished_ok",
                   status == "B" ~ "finished_not_payed",
                   status == "C" ~ "running_ok",
                   status == "D" ~ "running_client_in_dept"))

#Status in Faktor ändern
loan <- loan %>%
  mutate(status = as.factor(status))

loan <- loan %>%
  rename(loan_date = date)%>%
  mutate(loan_date = ymd(loan_date + 19000000))
```

Kontrolle der Änderungen.
```{r}
glimpse(loan)
summary(loan)
```
```{r}
ggplot(loan, aes(x = amount)) +
  geom_histogram(binwidth = 10000, color = "blue") +
  scale_x_continuous(breaks = seq(0, max(loan$amount), by = 50000)) +
  ggtitle("Vergebene loans in 10000 Schritten")
```
Gibt es Accounts, welche zwei mal einen Loan bekommen haben?
```{r}
sum(duplicated(loan$account_id))
```
```{r}
ggplot(loan, aes(x = duration, y = ..count.., fill = as.factor(duration))) +
  geom_bar() +
  labs(fill = "dauer") +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank())
```
Im Plot sehen wir 5 linien, diese ergeben sich aus der Duration. Im facet wrapet scatter plot sehen wir, dass vorallem die kleineren Beträge den Status finished_ok haben und die grösseren running_ok. Dieses bild zeigt sich auch be denen, welche nicht ok sind, die kleineren Beträge sind finished_not_payed und die grösseren running_in_dept
```{r}
ggplot(loan, aes(x = amount, y = payments, color = status)) +
  geom_point(size = 2, alpha = 0.5) +
  scale_x_continuous(labels = scales::comma_format(scale = 1e-3), breaks = seq(0, max(loan$amount), by = 100000)) +
  labs(x = "Amount in thousend")

ggplot(loan, aes(x = amount, y = payments, color = status)) +
  geom_point(size = 2, alpha = 0.5) +
  scale_x_continuous(labels = scales::comma_format(scale = 1e-3), breaks = seq(0, max(loan$amount), by = 100000)) +
  facet_wrap(vars(status)) +
  labs(x = "Amount in thousend")

ggplot(loan, aes(x = amount, y = payments, color = duration)) +
  geom_point(size = 2, alpha = 0.5) +
  scale_x_continuous(labels = scales::comma_format(scale = 1e-3), breaks = seq(0, max(loan$amount), by = 100000)) +
  labs(x = "Amount in thousend")
```

## order Datensatz
```{r}
order <- read.csv("data/order.csv", sep=";")
glimpse(order)
summary(order)
sum(is.na(order))
length(unique(order$order_id)) == nrow(order)
```

Hier sollen die beiden <chr> in <fct> geändert werden. Auch sollen die Werte in k_symbol verständlich werden.
```{r}
#K_symbol Werte verständlich machen
order <- order %>%
  mutate(k_symbol = case_when(k_symbol == "POJISTNE" ~ "insurrance payment",
                           k_symbol == "SIPO" ~ "household",
                           k_symbol == "LEASING" ~ "leasing",
                           k_symbol == "UVER" ~ "loan payment",
                           k_symbol == " " ~ NA,))

#Umwandlung in Faktor
order <- order %>%
  mutate(bank_to = as.factor(bank_to),
         k_symbol = as.factor(k_symbol))
```

Kontrolle der Daten.
```{r}
glimpse(order)
summary(order)
```

## trans Datensatz
```{r}
trans <- read.csv("data/trans.csv", sep=";")
glimpse(trans)
summary(trans)
sum(is.na(trans))
sum(is.na(trans$trans_id))
length(unique(trans$trans_id)) == nrow(trans)
```

Ändern der Tschechischen Namen, date in Datum formatieren und umwandlungen in Faktoren. Bei der spalte type werden in der Datenbeschreibung nur "PRIJEM" und "VYDAJ" beschrieben zudem kommt aber auch noch "VYBER" vor, dieser wird aber ansonsten als "withdrawal in cash" beschrieben, deshalb übernehmen wir dies auch hier.
```{r}
# Type Werte verständlich machen
trans <- trans %>%
  mutate(type = case_when(type == "PRIJEM" ~ "credit",
                          type == "VYDAJ" ~ "withdrawal",
                          type == "VYBER" ~ "withdrawal in cash"))

# Operation Werte verständlich machen
trans <- trans %>%
  mutate(operation = case_when(operation == "VYBER KARTOU" ~ "creditcard withdrawal",
                               operation == "VKLAD" ~ "credit in cash",
                               operation == "PREVOD Z UCTU" ~ "collection from another bank",
                               operation == "VYBER" ~ "withdrawal in cash",
                               operation == "PREVOD NA UCET" ~ "remittance to another bank"))


# K_symbol Werte verständlich machen
trans <- trans %>%
  mutate(k_symbol = case_when(k_symbol == "POJISTNE" ~ "insurrance payment",
                              k_symbol == "SLUZBY" ~ "paymant for statement",
                              k_symbol == "UROK" ~ "interest credited",
                              k_symbol == "SANKC. UROK" ~ "sanction interest if negative balance",
                              k_symbol == "SIPO" ~ "household",
                              k_symbol == "DUCHOD" ~ "old age pension",
                              k_symbol == "UVER" ~ "loan payment"))

# Datum umwandeln
trans$date <- ymd(trans$date)

# Ändern in <fct>
trans <- trans %>%
  mutate(type = as.factor(type),
         operation = as.factor(operation),
         k_symbol = as.factor(k_symbol),
         bank = as.factor(bank))

trans <- trans %>%
  rename(
    balance_after_transaction = balance,
    account_receiver = account,
    bank_receiver = bank,
  )
```

Kontrolle der Änderungen
```{r}
glimpse(trans)
summary(trans)
```
# CAR




```{r}
client_analytical_record <- accounts %>%
  left_join(disp %>% filter(type == "OWNER") %>%
              rename_with(~paste0("owner_", .), -account_id), by = "account_id") %>%
  left_join(disp %>% filter(type == "DISPONENT") %>%
              rename_with(~paste0("user_", .), -account_id), by = "account_id")


client_analytical_record <- client_analytical_record %>%
  select(-owner_type, -user_type) %>%
  replace_na(list(
    user_disp_id = -1, 
    user_client_id = -1
  ))

client_analytical_record <- client_analytical_record %>%
  left_join(client, by = c("owner_client_id" = "client_id"))

client_analytical_record <- client_analytical_record %>%
  rename(
    owner_birthday = birthday,
    owner_district_id = district_id_client,
    owner_sex = sex
  )

client_analytical_record <- client_analytical_record %>%
  left_join(client, by = c("user_client_id" = "client_id"))

client_analytical_record <- client_analytical_record %>%
  rename(
    user_birthday = birthday,
    user_district_id = district_id_client,
    user_sex = sex
  )

client_analytical_record <- client_analytical_record %>%
  left_join(loan, by = "account_id") %>%
  rename(
    loan_amount = amount,
    loan_duration = duration,
    loan_payments = payments,
    loan_status = status
  )

client_analytical_record <- client_analytical_record %>%
  left_join(card, by = c("owner_disp_id" = "disp_id"))%>%
  rename(
    card_issued = issued,
  )

client_analytical_record_no_district <- client_analytical_record

client_analytical_record <- client_analytical_record %>%
  left_join(district, by = c("owner_district_id" = "district_id"))

client_analytical_record <- client_analytical_record %>%
  select(-year.x, -year.y)

# Replace NA in columns starting with 'user_'
client_analytical_record <- client_analytical_record %>%
  mutate(across(starts_with("user_"), ~replace(., is.na(.), -1)))

glimpse(client_analytical_record)
```

Neues Dataframe erstellen mit account ID zum Joinen und monatliche ausgaben und einnahmen einzelner accounts ende Monat erstellen.

```{r}
trans_per_month <- trans %>%
  mutate(year_month = floor_date(date, unit = "month")) %>%
  group_by(account_id, year_month) %>%
  summarise(
    einnahmen = sum(amount[type == "credit"]),
    ausgaben = sum(amount[type == "withdrawal in cash" | type == "withdrawal"]), .groups = "drop"
    )
```

Es soll nun noch eine Spalte erstellt werden, um zu schauen, wieviel die verschiedenen Accounts jeweils am ende des Monats haben. Da wir die Vermutung haben dass alle zu beginn mit 0 auf dem Konto gestartet haben überprüfen wir dies im ersten Schritt kurz.
```{r}
#Dataframe erstellen um zu überprüfen, bei welchen accounts der amount und die balance nach der Transaktion gleich sind beim erst möglichen Datum.
kontostand_erster_Zeitpunkt <- trans %>%
  group_by(account_id) %>%
  filter(balance_after_transaction == amount) %>%
  slice_min(date) %>%
  ungroup()

# Überprüfen, ob jede account_id im Datensatz enthalten ist
all(unique(trans$account_id) %in% unique(kontostand_erster_Zeitpunkt$account_id))
```

Da wir nun Wissen, dass alle Accounts mit 0 begonnen haben, können wir in der trans_per_month liste die Balances min den Weren der vorherigen Monaten berechnen.
```{r}
trans_per_month <- trans_per_month %>%
  group_by(account_id) %>%
  mutate(kontostand_ende_monat = cumsum(einnahmen - ausgaben)) %>%
  ungroup()
```

Es sollen nun alle Daten für jedes Konto erstellt werden, auch wenn zu diesem Zeitpunkt keine Transaktionen über dieses Konto gelaufen sind.
```{r}
#Alle Transaktionen für alle zeiträume erstellen.
trans_per_month <- trans_per_month %>%
  complete(year_month = seq.Date(min(year_month), max(year_month), by="month"), account_id) %>%
  mutate(einnahmen = ifelse(is.na(einnahmen), 0, einnahmen)) %>%
  mutate(ausgaben = ifelse(is.na(ausgaben), 0, ausgaben)) %>%
  group_by(account_id) %>%
  fill(kontostand_ende_monat) %>%
  ungroup()

#Vor der ersten transktion soll das konto 0 betragen
trans_per_month <- trans_per_month %>%
  mutate(kontostand_ende_monat = ifelse(is.na(kontostand_ende_monat), 0, kontostand_ende_monat))

#ändern der Monatsanzeige
trans_per_month <- trans_per_month %>%
  mutate(year_month = (format(year_month, "%Y-%m")))
  
```


Trans_per_month ändern, dass jeder monat ein Attribut wird und der Accout nur eine Zeile hat.
```{r}
trans_per_month_new <- trans_per_month %>%
  pivot_wider(
    id_cols = account_id,
    names_from = year_month,
    values_from = c(einnahmen, ausgaben, kontostand_ende_monat),
    names_sort = TRUE
  ) 
```

Die neue Trans_per_month_new Liste wird nun an das CAR angehängt.
```{r}
client_analytical_record <- client_analytical_record %>%
  left_join(trans_per_month_new, by = c("account_id" = "account_id"))

client_analytical_record_no_district <- client_analytical_record_no_district %>%
  left_join(trans_per_month_new, by = c("account_id" = "account_id"))
```


```{r}
accounts_with_loan <- loan$account_id
loan_dates <- loan$loan_date

transactions_accounts_with_loan <- trans %>%
  filter(account_id %in% accounts_with_loan) %>%
  group_by(account_id, date) %>%
  summarise(
    einnahmen = sum(amount[type == "credit"]),
    ausgaben = sum(amount[type == "withdrawal in cash" | type == "withdrawal"]), .groups = "drop"
    ) %>%
  complete(date = seq.Date(min(date), max(date), by = "day"), account_id, fill = list(einnahmen = 0, ausgaben = 0)) %>%
  group_by(account_id) %>%
  arrange(date) %>%
  mutate(saldo = cumsum(einnahmen - ausgaben)) %>%
  fill(saldo, .direction = "downup") %>%
  ungroup() %>%
  left_join(loan, by = "account_id") %>%
  mutate(days_before_loan = as.numeric(loan_date - date),
         weeks_before_loan = ceiling(days_before_loan / 7)
         ) %>%
  filter(days_before_loan >= 0 & days_before_loan <= 183)

glimpse(transactions_accounts_with_loan)
summary(transactions_accounts_with_loan)
```

```{r}

```

```{r}
names(transactions_accounts_with_loan)
```


```{r}
mean_values_per_duration <- transactions_accounts_with_loan %>%
  group_by(duration, days_before_loan) %>%
  summarise(
    mean_einnahmen = mean(einnahmen, na.rm = TRUE),
    mean_ausgaben = mean(ausgaben, na.rm = TRUE),
    mean_saldo = mean(saldo, na.rm = TRUE),
    .groups = "drop"
  )

# Then perform your aggregations by 'weeks_before_loan'
mean_values_per_week <- transactions_accounts_with_loan %>%
  group_by(duration, weeks_before_loan) %>%
  summarise(
    mean_einnahmen = mean(einnahmen, na.rm = TRUE),
    mean_ausgaben = mean(ausgaben, na.rm = TRUE),
    mean_saldo = mean(saldo, na.rm = TRUE),
    .groups = "drop"
  )

# Create three separate plots for weekly data
# Plot for einnahmen
# ggplot(mean_values_per_week, aes(x = weeks_before_loan, y = mean_einnahmen, color = as.factor(duration))) +
#   geom_line(size = 1.2) +
#   scale_x_reverse(breaks = seq(0, max(weeks_before_loan), by = 4), limits = c(max(weeks_before_loan), 0)) +
#   labs(x = "Weeks Before Loan", y = "Average Einnahmen", color = "Loan Duration", title = "Weekly Average Einnahmen Trend by Loan Duration") +
#   theme_minimal()

# # Plot for ausgaben
# ggplot(mean_values_per_week, aes(x = week_before_loan, y = mean_ausgaben, color = as.factor(duration))) +
#   geom_line(size = 1.2) +
#   scale_x_reverse(breaks = seq(0, max(week_before_loan), by = 4), limits = c(max(week_before_loan), 0)) +
#   labs(x = "Weeks Before Loan", y = "Average Ausgaben", color = "Loan Duration", title = "Weekly Average Ausgaben Trend by Loan Duration") +
#   theme_minimal()
# 
# # Plot for saldo
# ggplot(mean_values_per_week, aes(x = week_before_loan, y = mean_saldo, color = as.factor(duration))) +
#   geom_line(size = 1.2) +
#   scale_x_reverse(breaks = seq(0, max(week_before_loan), by = 4), limits = c(max(week_before_loan), 0)) +
#   labs(x = "Weeks Before Loan", y = "Average Saldo", color = "Loan Duration", title = "Weekly Average Saldo Trend by Loan Duration") +
#   theme_minimal()

```

```{r}
# ggplot(transactions_accounts_with_loan, aes(x = days_before_loan, y = saldo)) +
#   geom_smooth(method = "loess", span = 0.2) +  # 'span' controls the smoothness
#   labs(x = "Days Before Loan", y = "Saldo", title = "Smoothed Trend of Saldo Before Loan") +
#   theme_minimal()
```

Kontrolle ob es ein muster in den Statusen gibt.
```{r}
transactions_accounts_with_loan %>%
  group_by(account_id) %>%
  filter(days_before_loan == 0) %>%
  ggplot(aes(x = amount, y = saldo, color = status)) +
  geom_point(size = 1) +
  scale_x_continuous(labels = scales::number_format(scale = 1e+0)) +
  ggtitle("Saldo und Amount verglichen")

transactions_accounts_with_loan %>%
  group_by(account_id) %>%
  filter(days_before_loan == 0) %>%
  ggplot(aes(x = amount, y = saldo, color = status)) +
  geom_point(size = 1) +
  facet_wrap(~status) +
  scale_x_continuous(labels = scales::number_format(scale = 1e+0)) +
  ggtitle("Saldo und Amount vergleichen, nach Status aufgeteilt")
```


```{r}
transactions_accounts_with_loan %>%
  group_by(days_before_loan, status) %>%
  summarize(gemitteltes_saldo = mean(saldo), .groups = "drop") %>%
  ggplot(aes(x = days_before_loan, y = gemitteltes_saldo, group = status, color = status)) +
  geom_line() +
  scale_x_reverse() +
  ggtitle("Mittelwert des Saldos vor beginn des Kredits")

transactions_accounts_with_loan %>%
  group_by(days_before_loan, status) %>%
  summarize(median_saldo = median(saldo), .groups = "drop") %>%
  ggplot(aes(x = days_before_loan, y = median_saldo, group = status, color = status)) +
  geom_line() +
  scale_x_reverse() +
  ggtitle("Median des Saldos vor beginn des Kredits")

transactions_accounts_with_loan %>%
  group_by(days_before_loan, status) %>%
  summarize(min_saldo = min(saldo), .groups = "drop") %>%
  ggplot(aes(x = days_before_loan, y = min_saldo, group = status, color = status)) +
  geom_line() +
  scale_x_reverse() +
  ggtitle("Minimales Saldo vor beginn des Kredits")

transactions_accounts_with_loan %>%
  group_by(days_before_loan, status) %>%
  summarize(max_saldo = max(saldo), .groups = "drop") %>%
  ggplot(aes(x = days_before_loan, y = max_saldo, group = status, color = status)) +
  geom_line() +
  scale_x_reverse() +
  ggtitle("Maximales Saldo vor beginn des Kredits")
```

```{r}
transactions_accounts_with_loan %>%
  distinct(loan_id, .keep_all = TRUE) %>%
  ggplot(aes(x = as.factor(duration), fill = factor(status, levels = c("running_client_in_dept", "finished_not_payed", "running_ok", "finished_ok")))) +
  geom_bar() +
  labs(title = "Dauer des Loans zu Status", fill = "Status", x ="Dauer in Monaten")

```

```{r}
transactions_accounts_with_loan %>%
  filter(status %in% c("running_ok", "finished_ok")) %>%
  group_by(account_id) %>%
  summarize(total_income = sum(einnahmen),
            total_expenses = sum(ausgaben),
            total_difference = total_income - total_expenses,
            amount = first(amount)) %>%
  ggplot(aes(x = total_difference, y = amount)) +
  geom_point(alpha = 0.5) +
  scale_y_continuous(labels = scales::number_format(scale = 1e+0)) +
  labs(title = "Amount zu Differenzfür Status OK")

transactions_accounts_with_loan %>%
  filter(status %in% c("running_client_in_dept", "finished_not_payed")) %>%
  group_by(account_id) %>%
  summarize(total_income = sum(einnahmen),
            total_expenses = sum(ausgaben),
            total_difference = total_income - total_expenses,
            amount = first(amount)) %>%
  ggplot(aes(x = total_difference, y = amount)) +
  geom_point(alpha = 0.5) +
  scale_y_continuous(labels = scales::number_format(scale = 1e+0)) +
  labs(title = "Amount zu Differenz für Status not_OK und in_dept")
```

```{r}
# Plot für alle Accounts
transactions_accounts_with_loan %>%
  filter(status %in% c("running_ok", "finished_ok")) %>%
  ggplot(aes(x = days_before_loan, y = saldo, group = account_id, color = account_id)) +
  geom_line(alpha = 0.2, size = 0.7) +
  scale_x_reverse() +
  scale_color_viridis_c() +
  labs(title = "Accounts", color = "Account")

# Sequenzen von Accounts
account_sequences <- list(c(0:999), c(1000:1999), c(2000:2999), c(3000:3999), c(4000:4999))

for (seq in account_sequences) {
  print(
    transactions_accounts_with_loan %>%
      filter(status %in% c("running_ok", "finished_ok")) %>%
      filter(account_id %in% seq) %>%
      ggplot(aes(x = days_before_loan, y = saldo, group = account_id, color = as.factor(account_id))) +
      geom_line(alpha = 0.5, size = 0.7) +
      scale_x_reverse() +  
      scale_color_discrete() +
      ggtitle(paste("Accounts", min(seq), "to", max(seq))) +
      labs(color = "Account") +
      theme(legend.title = element_text(size = 8),
            legend.key.size = unit(0.5, "cm"))
  )
}
```

```{r}
car_one_hot <- client_analytical_record_no_district %>%
  mutate(has_user = ifelse(!is.na(user_sex), 1, 0),
         has_card = ifelse(!is.na(card_id), 1, 0),
         ) %>% 
  select(-starts_with("user_")) %>%
  select(-year.x, -year.y, -card_issued, -loan_id, -loan_date, -card_id, -owner_client_id, -owner_disp_id) %>%
  pivot_wider(names_from = owner_sex, values_from = owner_sex,
              values_fill = list(owner_sex = 0),
              values_fn = list(owner_sex = length)) %>%
  pivot_wider(names_from = loan_status, values_from = loan_status,
              values_fill = list(loan_status = 0),
              values_fn = list(loan_status = length)) %>%
  select(-'NA')  %>%
  pivot_wider(names_from = card_type, values_from = card_type,
              values_fill = list(card_type = 0),
              values_fn = list(card_type = length)) %>%
    pivot_wider(names_from = frequency_of_statements, values_from = frequency_of_statements,
              values_fill = list(frequency_of_statements = 0),
              values_fn = list(frequency_of_statements = length)) %>%
  select(-'NA') %>%
  mutate(across(starts_with("loan_"), ~ replace_na(., 0))) %>%
  rename(
    loan_finished_ok = finished_ok,
    loan_finished_not_payed = finished_not_payed,
    loan_running_in_dept = running_client_in_dept,
    loan_running_ok = running_ok,
    gold_card = gold,
    junior_card = junior,
    classic_card = classic
  )

# Identify columns that start with 'kontostand_ende'
columns_to_normalize <- grep("^(ausgaben_|einnahmen_|kontostand_ende)", names(car_one_hot), value = TRUE)

# Apply Z-Score Normalization
for(col in columns_to_normalize) {
    car_one_hot[[col]] <- scale(car_one_hot[[col]])
}

# 
car_one_hot$account_age <- as.numeric(difftime(Sys.Date(), car_one_hot$opening_date, units = "days"))
car_one_hot$normalized_account_age <- scale(car_one_hot$account_age)

car_one_hot$owner_age <- as.numeric(difftime(Sys.Date(), car_one_hot$owner_birthday, units = "days"))
car_one_hot$normalized_owner_age <- scale(car_one_hot$owner_age)


car_one_hot <- car_one_hot %>%
  select(-account_age, -opening_date, -owner_birthday, -owner_age)

names(car_one_hot) <- gsub("-", "_", names(car_one_hot))
names(car_one_hot) <- gsub(" ", "_", names(car_one_hot))

summarise(car_one_hot)
```

```{r}
# create is_good_loan and make it a factor
one_hot_loans <- car_one_hot %>%
  filter(account_id %in% accounts_with_loan) %>%
  mutate(is_good_loan = ifelse(loan_finished_ok == 1 | loan_running_ok == 1, 1, 0)) %>%
  select(-loan_finished_ok, -loan_running_ok, -loan_finished_not_payed, -loan_running_in_dept) %>%
  mutate(is_good_loan = as.factor(is_good_loan))

accounts_is_good_loan <- one_hot_loans %>%
  filter(is_good_loan == 1) %>%
  select(account_id)

one_hot_no_loan <- car_one_hot %>%
  filter(!account_id %in% accounts_with_loan) %>%
  select(-loan_finished_ok, -loan_running_ok, -loan_finished_not_payed, -loan_running_in_dept)

```

```{r}
# names(train_set)


```


```{r}
# Splitting the data into training and test sets
set.seed(123) # for reproducibility
split <- createDataPartition(one_hot_loans$is_good_loan, p = .8, list = FALSE)
train_set <- one_hot_loans[split,]
test_set <- one_hot_loans[-split,]


# Training the model
model <- randomForest(is_good_loan ~ ., data = train_set)

# Evaluating the model on the test set
predictions <- predict(model, test_set)
confusionMatrix(predictions, test_set$is_good_loan)
```
```{r}
# Extracting variable importance
importance_scores <- importance(model)
# Sorting the importance scores in descending order
sorted_importance <- sort(importance_scores[, "MeanDecreaseGini"], decreasing = TRUE)
# Printing the sorted importance scores
head(sorted_importance, 10)
```

```{r}
# Configure Cross-Validation
# Setting up 10-fold cross-validation
train_control <- trainControl(method = "cv", number = 10)

# Train the model with cross-validation
model_cv <- train(is_good_loan ~ ., data = train_set, method = "rf", trControl = train_control)

# Print the results
print(model_cv)

# Detailed performance metrics
confusionMatrix(model_cv)
```

```{r}
# Getting column names that start with specified prefixes
transaction_cols <- grep("^(einnahmen_|ausgaben_|kontostand_)", names(one_hot_loans), value = TRUE)
loan_cols <- grep("^(loan_)", names(one_hot_loans), value = TRUE)

# Selecting columns that don't start with the specified prefixes
selected_cols <- setdiff(names(one_hot_loans), c(transaction_cols, loan_cols, "account_id"))

# Creating a new dataframe with only the selected columns
train_data_subset <- one_hot_loans[selected_cols]

split <- createDataPartition(train_data_subset$is_good_loan, p = .8, list = FALSE)
train_set <- train_data_subset[split,]
test_set <- train_data_subset[-split,]


# Training the model
model <- randomForest(is_good_loan ~ ., data = train_set)

# Evaluating the model on the test set
predictions <- predict(model, test_set)
confusionMatrix(predictions, test_set$is_good_loan)

# Extracting variable importance
importance_scores <- importance(model)
# Sorting the importance scores in descending order
sorted_importance <- sort(importance_scores[, "MeanDecreaseGini"], decreasing = TRUE)
# Printing the sorted importance scores
print(sorted_importance)
```
### train on 183 days bevore loan
```{r}
wide_183_days_before_loan <- transactions_accounts_with_loan %>%
  pivot_wider(
    id_cols = account_id,
    names_from = days_before_loan,
    values_from = c(einnahmen, ausgaben, saldo),
    names_glue = "{.value}_{183 - days_before_loan}_dbf"
  )

#NAs durch 0 ersetzen. Bei den NAs handelt es sich um Werte vor beginn der Datenaufzeichnung es sind also keine Transaktionen möglich gewesen bei den NAs.
wide_183_days_before_loan <- wide_183_days_before_loan %>%
  mutate(across(everything(), ~ifelse(is.na(.), 0, .)))
# accounts_is_good_loan
wide_183_days_before_loan <- wide_183_days_before_loan %>% 
  mutate(good_for_loan = ifelse(account_id %in% accounts_is_good_loan$account_id, 1, 0),
         good_for_loan = as.factor(good_for_loan))

# Selecting balance columns (excluding account_id)
balance_cols <- setdiff(names(wide_183_days_before_loan), c("account_id", "good_for_loan"))

# Applying Z-score normalization
wide_183_days_before_loan[balance_cols] <- scale(wide_183_days_before_loan[balance_cols])

# Setting up the train-test split
set.seed(123) # For reproducibility
splitIndex <- createDataPartition(wide_183_days_before_loan$good_for_loan, p = .8, list = FALSE)
train_set <- wide_183_days_before_loan[splitIndex, ]
test_set <- wide_183_days_before_loan[-splitIndex, ]

# Training a Random Forest model
model <- randomForest(good_for_loan ~ ., data = train_set, method = "rf")

# Predictions
predictions <- predict(model, test_set)

# Evaluation
confusionMatrix(predictions, test_set$good_for_loan)

```

```{r}
colSums(is.na(transactions_accounts_with_loan)) %>%
  sort(decreasing = TRUE)
```

```{r}
#Dataframe für training random Forest erstellen bis ende 1997

CAR_random_forest <- client_analytical_record_no_district %>%
  filter(!loan_status %in% c("finished_not_payed", "running_client_in dept") | is.na(loan_status)) %>%
  filter(loan_date < "1998-01-01" | is.na(loan_date)) %>%
  select(-user_disp_id, -user_client_id, -user_district_id, -user_sex, 
         -loan_id, -loan_date, -loan_amount, -loan_duration, -loan_payments, -loan_status, 
         -card_id, -card_issued, 
         -contains("1998"), -year.x, -year.y, -user_birthday) %>%
  mutate(get_loan = as.factor(ifelse(account_id %in% loan$account_id | is.na(account_id), 1, 0))) %>%
  mutate(card_type = as.factor(coalesce(card_type, "noCard")))

# Ersetze <, >, =, - durch Unterstrich im gesamten Dataframe
colnames(CAR_random_forest) <- gsub("[<>=-]", "_", colnames(CAR_random_forest))

```

```{r}
set.seed(123)
splitIndex_new <- createDataPartition(CAR_random_forest$get_loan, p = .8, list = FALSE)
train_set_new <- CAR_random_forest[splitIndex_new, ]
test_set_new <- CAR_random_forest[-splitIndex_new, ]

new_model <- randomForest(get_loan ~ . - get_loan, data = train_set_new, method = "rf")

predictions_new <- predict(new_model, test_set_new)

confusionMatrix(predictions_new, test_set_new$get_loan, mode = "everything", positive = "1")

```

```{r}
#Dataframe für training random Forest erstellen bis ende 1997

CAR_random_forest_with_dist <- client_analytical_record %>%
  filter(!loan_status %in% c("finished_not_payed", "running_client_in dept") | is.na(loan_status)) %>%
  filter(loan_date < "1998-01-01" | is.na(loan_date)) %>%
  select(-user_disp_id, -user_client_id, -user_district_id, -user_sex, 
         -loan_id, -loan_date, -loan_amount, -loan_duration, -loan_payments, -loan_status, 
         -card_id, -card_issued, -user_birthday, -district_name, -unemploymant_rate_95,
         -commited_crimes_95, -crimes_per_1000_1995) %>%
  select(-matches("1998"), -contains("1998"), everything()) %>%
  mutate(get_loan = as.factor(ifelse(account_id %in% loan$account_id | is.na(account_id), 1, 0))) %>%
  mutate(card_type = as.factor(coalesce(card_type, "noCard")))

# Ersetze <, >, =, - durch Unterstrich im gesamten Dataframe
colnames(CAR_random_forest_with_dist) <- gsub("[<>=-]", "_", colnames(CAR_random_forest_with_dist))
```

```{r}
set.seed(123)
splitIndex_new_dist <- createDataPartition(CAR_random_forest_with_dist$get_loan, p = .8, list = FALSE)
train_set_new_dist <- CAR_random_forest_with_dist[splitIndex_new_dist, ]
test_set_new_dist <- CAR_random_forest_with_dist[-splitIndex_new_dist, ]

new_model_dist <- randomForest(get_loan ~ ., data = train_set_new_dist, method = "rf")

predictions_new_dist <- predict(new_model_dist, test_set_new_dist)

confusionMatrix(predictions_new_dist, test_set_new_dist$get_loan, mode = "everything", positive = "1")

```
Erstellen eines Dataframes für alle mit Loan 13 Monate vor Beginn des Loans
```{r}
df_loan_13_month <- trans_per_month %>%
  filter(account_id %in% loan$account_id) %>%
  left_join(loan, by = "account_id") %>%
  mutate(loan_date = floor_date(loan_date, unit = "month")) %>%
  mutate(year_month = ym(year_month)) %>%
  mutate(loan_date = as.Date((loan_date), format = "%Y-%m")) %>%
  mutate(months_before_loan = (year_month)-(loan_date)) %>%
  filter(status %in% c("finished_ok", "running_ok")) %>%
  
  mutate(months_before_loan = as.numeric(round(months_before_loan * (-1) / 30))) %>%
  filter(months_before_loan >= 0 & months_before_loan <= 12) %>%
  
  pivot_wider(
    id_cols = account_id,
    names_from = months_before_loan,
    values_from = c(einnahmen, ausgaben, kontostand_ende_monat),
    names_sort = TRUE) %>%
  mutate(get_loan = "yes") %>%
  #NAs sind für Zeiten vor der Aufzeichnung der Daten und daher 0
  mutate(across(everything(), ~ifelse(is.na(.), 0, .)))
```

Erstellen eines Dataframes für alle ohne Loan im Jahr 1997
```{r}
df_no_loan_13_month <- trans_per_month %>%
  filter(!(account_id %in% loan$account_id)) %>%
  mutate(loan_date = "1997-11") %>%
  mutate(loan_date = ym(loan_date)) %>%
  mutate(year_month = ym(year_month)) %>%
  mutate(loan_date = as.Date((loan_date), format = "%Y-%m")) %>%
  mutate(months_before_loan = (year_month)-(loan_date)) %>%

  mutate(months_before_loan = as.numeric(round(months_before_loan * (-1) / 30))) %>%
  filter(months_before_loan >= 0 & months_before_loan <= 12) %>%
  
  pivot_wider(
    id_cols = account_id,
    names_from = months_before_loan,
    values_from = c(einnahmen, ausgaben, kontostand_ende_monat),
    names_sort = TRUE) %>%
    
  mutate(get_loan = "no")
```

Tabellen zusammenfügen
```{r}
df_complete_loan_13_month <- merge(df_loan_13_month, df_no_loan_13_month, all = TRUE)
```

